# Animation System Scripts Export
Generado: 2025-10-29 04:43:08

==== BEGIN Assets/Scripts/BattleV2/AnimationSystem/IAnimationOrchestrator.cs ====
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using BattleV2.Core;
using BattleV2.Providers;

namespace BattleV2.AnimationSystem
{
    /// <summary>
    /// Entry point for the data-driven JRPG animation pipeline.
    /// Implementations must execute the request and resolve when
    /// the orchestration is complete.
    /// </summary>
    public interface IAnimationOrchestrator
    {
        Task PlayAsync(AnimationRequest request, CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// Canonical payload for animation executions. Mirrors the
    /// existing battle pipeline contract so legacy adapters can
    /// participate until the new system is ready.
    /// </summary>
    public readonly struct AnimationRequest
    {
        public AnimationRequest(
            CombatantState actor,
            BattleSelection selection,
            IReadOnlyList<CombatantState> targets,
            float averageSpeed)
        {
            Actor = actor;
            Selection = selection;
            Targets = targets ?? System.Array.Empty<CombatantState>();
            AverageSpeed = averageSpeed <= 0f ? 1f : averageSpeed;
            ActorSpeed = actor != null ? actor.FinalStats.Speed : 1f;
        }

        public AnimationRequest(
            CombatantState actor,
            BattleSelection selection,
            IReadOnlyList<CombatantState> targets)
            : this(actor, selection, targets, 1f)
        {
        }

        public CombatantState Actor { get; }
        public BattleSelection Selection { get; }
        public IReadOnlyList<CombatantState> Targets { get; }
        public float AverageSpeed { get; }
        public float ActorSpeed { get; }
    }
}
==== END Assets/Scripts/BattleV2/AnimationSystem/IAnimationOrchestrator.cs ====

==== BEGIN Assets/Scripts/BattleV2/AnimationSystem/CombatClock.cs ====
using System;
using UnityEngine;

namespace BattleV2.AnimationSystem
{
    public interface ICombatClock
    {
        double Now { get; }
        void Reset();
        void Sample();
    }

    /// <summary>
    /// Monotonic clock backed by Unity's unscaled time. Consumers
    /// must call <see cref="Sample"/> to update the cached value.
    /// </summary>
    public sealed class CombatClock : ICombatClock
    {
        private readonly Func<double> timeProvider;
        private double startTime;
        private double current;

        public CombatClock()
            : this(() => Time.unscaledTimeAsDouble)
        {
        }

        public CombatClock(Func<double> customProvider)
        {
            timeProvider = customProvider ?? throw new ArgumentNullException(nameof(customProvider));
            Reset();
        }

        public double Now => current;

        public void Reset()
        {
            startTime = timeProvider();
            current = 0d;
        }

        public void Sample()
        {
            double elapsed = timeProvider() - startTime;
            if (elapsed < 0d)
            {
                elapsed = 0d;
            }

            current = Math.Max(current, elapsed);
        }
    }
}
==== END Assets/Scripts/BattleV2/AnimationSystem/CombatClock.cs ====

==== BEGIN Assets/Scripts/BattleV2/AnimationSystem/AnimationEventBus.cs ====
using System;
using System.Collections.Generic;
using BattleV2.Actions;
using BattleV2.Core;
using BattleV2.Providers;

namespace BattleV2.AnimationSystem
{
    public interface IAnimationEventBus
    {
        void Publish<TEvent>(TEvent evt) where TEvent : struct;
        IDisposable Subscribe<TEvent>(Action<TEvent> handler) where TEvent : struct;
    }

    /// <summary>
    /// Lightweight synchronous pub/sub tailored for the JRPG animation pipeline.
    /// </summary>
    public sealed class AnimationEventBus : IAnimationEventBus
    {
        private readonly Dictionary<Type, List<Delegate>> subscribers = new();

        public void Publish<TEvent>(TEvent evt) where TEvent : struct
        {
            var type = typeof(TEvent);
            if (!subscribers.TryGetValue(type, out var handlers))
            {
                return;
            }

            for (int i = 0; i < handlers.Count; i++)
            {
                if (handlers[i] is Action<TEvent> action)
                {
                    action(evt);
                }
            }
        }

        public IDisposable Subscribe<TEvent>(Action<TEvent> handler) where TEvent : struct
        {
            if (handler == null)
            {
                return EmptyDisposable.Instance;
            }

            var type = typeof(TEvent);
            if (!subscribers.TryGetValue(type, out var handlers))
            {
                handlers = new List<Delegate>();
                subscribers[type] = handlers;
            }

            handlers.Add(handler);

            return new Subscription(() =>
            {
                if (!subscribers.TryGetValue(type, out var list))
                {
                    return;
                }

                list.Remove(handler);
                if (list.Count == 0)
                {
                    subscribers.Remove(type);
                }
            });
        }

        private sealed class Subscription : IDisposable
        {
            private Action dispose;

            public Subscription(Action disposal)
            {
                dispose = disposal;
            }

            public void Dispose()
            {
                dispose?.Invoke();
                dispose = null;
            }
        }

        private sealed class EmptyDisposable : IDisposable
        {
            public static readonly EmptyDisposable Instance = new();
            public void Dispose() { }
        }
    }

    #region Events

    public readonly struct AnimationPhaseEvent
    {
        public AnimationPhaseEvent(CombatantState actor, BattleSelection selection, int phaseIndex, int phaseCount, string payload)
        {
            Actor = actor;
            Selection = selection;
            PhaseIndex = phaseIndex;
            PhaseCount = phaseCount;
            Payload = payload;
        }

        public CombatantState Actor { get; }
        public BattleSelection Selection { get; }
        public int PhaseIndex { get; }
        public int PhaseCount { get; }
        public string Payload { get; }
    }

    public readonly struct AnimationImpactEvent
    {
        public AnimationImpactEvent(
            CombatantState actor,
            CombatantState target,
            BattleActionData action,
            int impactIndex,
            int impactCount,
            string tag,
            string payload)
        {
            Actor = actor;
            Target = target;
            Action = action;
            ImpactIndex = impactIndex;
            ImpactCount = impactCount;
            Tag = tag;
            Payload = payload;
        }

        public CombatantState Actor { get; }
        public CombatantState Target { get; }
        public BattleActionData Action { get; }
        public int ImpactIndex { get; }
        public int ImpactCount { get; }
        public string Tag { get; }
        public string Payload { get; }
    }

    public readonly struct AnimationWindowEvent
    {
        public AnimationWindowEvent(CombatantState actor, string tag, float windowStart, float windowEnd, bool isOpening)
        {
            Actor = actor;
            Tag = tag;
            WindowStart = windowStart;
            WindowEnd = windowEnd;
            IsOpening = isOpening;
        }

        public CombatantState Actor { get; }
        public string Tag { get; }
        public float WindowStart { get; }
        public float WindowEnd { get; }
        public bool IsOpening { get; }
    }

    public readonly struct AnimationLockEvent
    {
        public AnimationLockEvent(CombatantState actor, bool isLocked, string reason)
        {
            Actor = actor;
            IsLocked = isLocked;
            Reason = reason;
        }

        public CombatantState Actor { get; }
        public bool IsLocked { get; }
        public string Reason { get; }
    }

    #endregion
}
==== END Assets/Scripts/BattleV2/AnimationSystem/AnimationEventBus.cs ====

==== BEGIN Assets/Scripts/BattleV2/AnimationSystem/LegacyAnimationOrchestratorAdapter.cs ====
using System.Threading;
using System.Threading.Tasks;
using BattleV2.Orchestration.Services;

namespace BattleV2.AnimationSystem
{
    /// <summary>
    /// Temporary adapter so the new animation contract can delegate
    /// to the legacy orchestrator without touching battle flow.
    /// </summary>
    public sealed class LegacyAnimationOrchestratorAdapter : IAnimationOrchestrator
    {
        private readonly IBattleAnimOrchestrator legacy;

        public LegacyAnimationOrchestratorAdapter(IBattleAnimOrchestrator legacyOrchestrator)
        {
            legacy = legacyOrchestrator;
        }

        public Task PlayAsync(AnimationRequest request, CancellationToken cancellationToken = default)
        {
            if (legacy == null)
            {
                return Task.CompletedTask;
            }

            var playback = new ActionPlaybackRequest(
                request.Actor,
                request.Selection,
                request.Targets,
                request.AverageSpeed);

            // Legacy orchestrator does not support cancellation; best-effort no-op.
            cancellationToken.ThrowIfCancellationRequested();
            return legacy.PlayAsync(playback);
        }
    }
}
==== END Assets/Scripts/BattleV2/AnimationSystem/LegacyAnimationOrchestratorAdapter.cs ====

==== BEGIN Assets/Scripts/BattleV2/AnimationSystem/Timelines/ActionTimeline.cs ====
using System;
using System.Collections.Generic;
using UnityEngine;

namespace BattleV2.AnimationSystem.Timelines
{
    [CreateAssetMenu(menuName = "Battle/Animation/Action Timeline", fileName = "NewActionTimeline")]
    public sealed class ActionTimeline : ScriptableObject
    {
        [SerializeField] private string actionId;
        [SerializeField] private string displayName;
        [SerializeField] private Metadata metadata = new();
        [SerializeField] private List<Track> tracks = new();

        public string ActionId => actionId;
        public string DisplayName => string.IsNullOrWhiteSpace(displayName) ? actionId : displayName;
        public Metadata Info => metadata;
        public IReadOnlyList<Track> Tracks => tracks;

        [Serializable]
        public struct Metadata
        {
            [Tooltip("Duracion total normalizada (0..1) -> se escala segun velocidad y clock.")]
            public float Length;

            [Tooltip("Etiquetas libres para filtros (por ejemplo: melee, magic, projectile).")]
            public string[] Tags;
        }

        [Serializable]
        public struct Track
        {
            [SerializeField] private TrackType type;
            [SerializeField] private List<Phase> phases;

            public TrackType Type => type;
            public IReadOnlyList<Phase> Phases => phases;
        }

        [Serializable]
        public struct Phase
        {
            [Range(0f, 1f)]
            public float Start;

            [Range(0f, 1f)]
            public float End;

            [Tooltip("Evento emitido al comenzar la fase.")]
            public string OnEnterEvent;

            [Tooltip("Evento emitido al finalizar la fase.")]
            public string OnExitEvent;

            [Tooltip("Payload adicional para routers (por ejemplo VFX, SFX).")]
            public string Payload;
        }

        public enum TrackType
        {
            Animation,
            Impact,
            Window,
            Lock,
            Custom
        }
    }
}
==== END Assets/Scripts/BattleV2/AnimationSystem/Timelines/ActionTimeline.cs ====

==== BEGIN Assets/Scripts/BattleV2/AnimationSystem/Catalog/ActionTimelineCatalog.cs ====
using System;
using System.Collections.Generic;
using UnityEngine;
using BattleV2.AnimationSystem.Timelines;

namespace BattleV2.AnimationSystem.Catalog
{
    [CreateAssetMenu(menuName = "Battle/Animation/Action Timeline Catalog", fileName = "ActionTimelineCatalog")]
    public sealed class ActionTimelineCatalog : ScriptableObject
    {
        [SerializeField] private List<ActionTimeline> timelines = new();
        [SerializeField] private bool logMissingTimelines = true;

        private readonly Dictionary<string, ActionTimeline> lookup = new(StringComparer.Ordinal);
        private bool initialized;

        public IReadOnlyList<ActionTimeline> Timelines => timelines;
        public int TimelineCount => timelines?.Count ?? 0;

        public void Initialize()
        {
            if (initialized)
            {
                return;
            }

            RebuildLookup();
        }

        [ContextMenu("Rebuild Lookup")]
        public void ForceRebuild()
        {
            initialized = false;
            RebuildLookup();
        }

        private void RebuildLookup()
        {
            lookup.Clear();
            bool anyRegistered = false;

            for (int i = 0; i < timelines.Count; i++)
            {
                var asset = timelines[i];
                if (asset == null)
                {
                    continue;
                }

                if (string.IsNullOrWhiteSpace(asset.ActionId))
                {
                    Debug.LogWarning($"[ActionTimelineCatalog] Timeline '{asset.name}' no tiene ActionId asignado.");
                    continue;
                }

                if (lookup.ContainsKey(asset.ActionId))
                {
                    Debug.LogWarning($"[ActionTimelineCatalog] Timeline duplicado para ActionId '{asset.ActionId}'. Se conservara la primera referencia.");
                    continue;
                }

                lookup[asset.ActionId] = asset;
                anyRegistered = true;
            }

            initialized = anyRegistered;
        }

        public bool TryGetTimeline(string actionId, out ActionTimeline timeline)
        {
            Initialize();
            if (lookup.TryGetValue(actionId, out timeline))
            {
                return true;
            }

            if (logMissingTimelines && !string.IsNullOrWhiteSpace(actionId))
            {
                Debug.LogWarning($"[ActionTimelineCatalog] No se encontro timeline para ActionId '{actionId}'.");
            }

            return false;
        }

        public ActionTimeline GetTimelineOrDefault(string actionId)
        {
            return TryGetTimeline(actionId, out var timeline) ? timeline : null;
        }
    }
}
==== END Assets/Scripts/BattleV2/AnimationSystem/Catalog/ActionTimelineCatalog.cs ====

==== BEGIN Assets/Scripts/BattleV2/AnimationSystem/Validation/ActionTimelineValidator.cs ====
using System;
using System.Collections.Generic;
using UnityEngine;
using BattleV2.AnimationSystem.Timelines;

namespace BattleV2.AnimationSystem.Validation
{
    public static class ActionTimelineValidator
    {
        public struct Result
        {
            public bool IsValid;
            public List<string> Errors;
            public List<string> Warnings;
            public int ErrorCount => Errors?.Count ?? 0;
            public int WarningCount => Warnings?.Count ?? 0;

            public void AddError(string message)
            {
                Errors ??= new List<string>();
                Errors.Add(message);
                IsValid = false;
            }

            public void AddWarning(string message)
            {
                Warnings ??= new List<string>();
                Warnings.Add(message);
            }
        }

        public static Result Validate(ActionTimeline timeline)
        {
            var result = new Result { IsValid = true };
            if (timeline == null)
            {
                result.AddError("Timeline reference es null.");
                return result;
            }

            if (string.IsNullOrWhiteSpace(timeline.ActionId))
            {
                result.AddError($"Timeline '{timeline.name}' necesita ActionId.");
            }

            float length = Mathf.Clamp01(timeline.Info.Length <= 0f ? 1f : timeline.Info.Length);
            var tracks = timeline.Tracks;
            if (tracks == null || tracks.Count == 0)
            {
                result.AddWarning($"Timeline '{timeline.ActionId}' no tiene tracks.");
                return result;
            }

            bool hasAnimationTrack = false;
            var globalTags = new HashSet<string>(StringComparer.Ordinal);

            for (int i = 0; i < tracks.Count; i++)
            {
                var track = tracks[i];
                if (track.Phases == null || track.Phases.Count == 0)
                {
                    result.AddWarning($"Track {track.Type} en '{timeline.ActionId}' esta vacio.");
                    continue;
                }

                if (track.Type == ActionTimeline.TrackType.Animation && track.Phases.Count > 0)
                {
                    hasAnimationTrack = true;
                }

                var sortedPhases = new List<ActionTimeline.Phase>(track.Phases);
                sortedPhases.Sort((a, b) => a.Start.CompareTo(b.Start));

                for (int p = 0; p < sortedPhases.Count; p++)
                {
                    var phase = sortedPhases[p];
                    if (phase.Start < 0f || phase.Start > 1f)
                    {
                        result.AddError($"Track {track.Type} fase {p} start fuera de rango (0..1).");
                    }

                    if (phase.End < phase.Start)
                    {
                        result.AddError($"Track {track.Type} fase {p} end < start.");
                    }

                    if (phase.End > length)
                    {
                        result.AddWarning($"Track {track.Type} fase {p} excede Length ({length}).");
                    }

                    if (p > 0)
                    {
                        var previous = sortedPhases[p - 1];
                        if (phase.Start < previous.End)
                        {
                            result.AddWarning($"Track {track.Type} presenta solapamiento entre fases que inician en {previous.Start:0.00}-{previous.End:0.00} y {phase.Start:0.00}-{phase.End:0.00}.");
                        }
                    }

                    CheckTag(globalTags, phase.OnEnterEvent, timeline.ActionId, ref result);
                    CheckTag(globalTags, phase.OnExitEvent, timeline.ActionId, ref result);
                }
            }

            if (!hasAnimationTrack)
            {
                result.AddWarning($"Timeline '{timeline.ActionId}' no define un track de Animation; verifica que el actor tenga una pose base.");
            }

            if (timeline.Info.Tags != null && timeline.Info.Tags.Length > 0)
            {
                var metaTags = new HashSet<string>(StringComparer.Ordinal);
                for (int t = 0; t < timeline.Info.Tags.Length; t++)
                {
                    var tag = timeline.Info.Tags[t];
                    if (string.IsNullOrWhiteSpace(tag))
                    {
                        result.AddWarning($"Timeline '{timeline.ActionId}' tiene una etiqueta vacia (indice {t}).");
                        continue;
                    }

                    if (!metaTags.Add(tag))
                    {
                        result.AddWarning($"Timeline '{timeline.ActionId}' repite la etiqueta '{tag}'.");
                    }
                }
            }

            return result;
        }

        private static void CheckTag(HashSet<string> globalTags, string tag, string actionId, ref Result result)
        {
            if (string.IsNullOrWhiteSpace(tag))
            {
                return;
            }

            if (!globalTags.Add(tag))
            {
                result.AddWarning($"Timeline '{actionId}' reutiliza el tag '{tag}'. Asegura unicidad para simplificar los routers.");
            }
        }
    }
}
==== END Assets/Scripts/BattleV2/AnimationSystem/Validation/ActionTimelineValidator.cs ====

==== BEGIN Assets/Scripts/BattleV2/AnimationSystem/Execution/TimelineCompiler.cs ====
using System;
using System.Collections.Generic;
using BattleV2.AnimationSystem.Timelines;

namespace BattleV2.AnimationSystem.Execution
{
    public interface ITimelineCompiler
    {
        CompiledTimeline Compile(ActionTimeline timeline, float timelineDuration);
    }

    public sealed class TimelineCompiler : ITimelineCompiler
    {
        public CompiledTimeline Compile(ActionTimeline timeline, float timelineDuration)
        {
            if (timeline == null)
            {
                throw new ArgumentNullException(nameof(timeline));
            }

            timelineDuration = Math.Max(0.1f, timelineDuration);

            var tracks = timeline.Tracks;
            if (tracks == null || tracks.Count == 0)
            {
                return CompiledTimeline.Empty;
            }

            var phases = new List<CompiledPhase>();
            for (int i = 0; i < tracks.Count; i++)
            {
                var track = tracks[i];
                if (track.Phases == null || track.Phases.Count == 0)
                {
                    continue;
                }

                foreach (var phase in track.Phases)
                {
                    float startNorm = Math.Clamp(phase.Start, 0f, 1f);
                    float endNorm = Math.Clamp(phase.End, startNorm, 1f);
                    float start = startNorm * timelineDuration;
                    float end = endNorm * timelineDuration;
                    phases.Add(new CompiledPhase(
                        track.Type,
                        start,
                        end,
                        startNorm,
                        endNorm,
                        phase.OnEnterEvent,
                        phase.OnExitEvent,
                        phase.Payload));
                }
            }

            phases.Sort((a, b) => a.Start.CompareTo(b.Start));
            return new CompiledTimeline(timeline.ActionId, timeline.DisplayName, timelineDuration, phases);
        }
    }

    public readonly struct CompiledTimeline
    {
        public static readonly CompiledTimeline Empty = new(string.Empty, string.Empty, 0f, Array.Empty<CompiledPhase>());

        public CompiledTimeline(string actionId, string displayName, float duration, IReadOnlyList<CompiledPhase> phases)
        {
            ActionId = actionId;
            DisplayName = displayName;
            Duration = duration;
            Phases = phases ?? Array.Empty<CompiledPhase>();
        }

        public string ActionId { get; }
        public string DisplayName { get; }
        public float Duration { get; }
        public IReadOnlyList<CompiledPhase> Phases { get; }

        public bool IsEmpty => Duration <= 0f || Phases == null || Phases.Count == 0;
    }

    public readonly struct CompiledPhase
    {
        public CompiledPhase(
            ActionTimeline.TrackType trackType,
            float start,
            float end,
            float startNormalized,
            float endNormalized,
            string enterEvent,
            string exitEvent,
            string payload)
        {
            Track = trackType;
            Start = start;
            End = end;
            StartNormalized = startNormalized;
            EndNormalized = endNormalized;
            EnterEvent = enterEvent;
            ExitEvent = exitEvent;
            Payload = payload;
        }

        public ActionTimeline.TrackType Track { get; }
        public float Start { get; }
        public float End { get; }
        public float StartNormalized { get; }
        public float EndNormalized { get; }
        public string EnterEvent { get; }
        public string ExitEvent { get; }
        public string Payload { get; }

        public override string ToString() =>
            $"{Track} [{Start:0.00}-{End:0.00}] enter={EnterEvent} exit={ExitEvent} payload={Payload}";
    }
}
==== END Assets/Scripts/BattleV2/AnimationSystem/Execution/TimelineCompiler.cs ====

==== BEGIN Assets/Scripts/BattleV2/AnimationSystem/Execution/ActionLockManager.cs ====
using System;
using System.Collections.Generic;

namespace BattleV2.AnimationSystem.Execution
{
    public interface IActionLockManager
    {
        void PushLock(string reason);
        void PopLock(string reason);
        bool IsLocked { get; }
        IReadOnlyList<string> Reasons { get; }
    }

    public sealed class ActionLockManager : IActionLockManager
    {
        private readonly List<string> reasons = new();

        public bool IsLocked => reasons.Count > 0;
        public IReadOnlyList<string> Reasons => reasons;

        public void PushLock(string reason)
        {
            if (string.IsNullOrWhiteSpace(reason))
            {
                reason = "unknown";
            }

            reasons.Add(reason);
        }

        public void PopLock(string reason)
        {
            if (string.IsNullOrWhiteSpace(reason))
            {
                throw new ArgumentException("Reason must be provided to pop a lock.", nameof(reason));
            }

            int index = reasons.LastIndexOf(reason);
            if (index >= 0)
            {
                reasons.RemoveAt(index);
            }
        }
    }
}
==== END Assets/Scripts/BattleV2/AnimationSystem/Execution/ActionLockManager.cs ====

==== BEGIN Assets/Scripts/BattleV2/AnimationSystem/Execution/ActionSequencer.cs ====
using System;
using System.Collections.Generic;
using BattleV2.AnimationSystem.Timelines;
using BattleV2.Core;
using BattleV2.Providers;

namespace BattleV2.AnimationSystem.Execution
{
    public sealed class ActionSequencer : IDisposable
    {
        private const double EventTolerance = 0.0001;

        private readonly AnimationRequest request;
        private readonly CompiledTimeline timeline;
        private readonly ICombatClock clock;
        private readonly IAnimationEventBus eventBus;
        private readonly IActionLockManager lockManager;
        private readonly List<ScheduledEvent> schedule;
        private readonly string baseLockReason;

        private int nextEvent;
        private double startTime;
        private bool started;
        private bool completed;
        private bool cancelled;

        public ActionSequencer(
            AnimationRequest request,
            CompiledTimeline timeline,
            ICombatClock clock,
            IAnimationEventBus eventBus,
            IActionLockManager lockManager)
        {
            this.request = request;
            this.timeline = timeline;
            this.clock = clock;
            this.eventBus = eventBus;
            this.lockManager = lockManager;

            baseLockReason = string.IsNullOrWhiteSpace(timeline.ActionId)
                ? "timeline"
                : $"timeline:{timeline.ActionId}";

            schedule = BuildSchedule(timeline);
        }

        public bool IsStarted => started;
        public bool IsCompleted => completed;
        public bool IsCancelled => cancelled;
        public CompiledTimeline Timeline => timeline;

        public void Start()
        {
            if (started)
            {
                return;
            }

            started = true;
            clock?.Sample();
            startTime = clock?.Now ?? 0d;

            lockManager?.PushLock(baseLockReason);
            PublishLockEvent(true, baseLockReason);
        }

        public void Tick()
        {
            if (!started || completed || cancelled)
            {
                return;
            }

            clock?.Sample();
            double now = clock?.Now ?? 0d;
            double elapsed = now - startTime;
            if (elapsed < 0d)
            {
                elapsed = 0d;
            }

            while (nextEvent < schedule.Count)
            {
                var current = schedule[nextEvent];
                if (current.TriggerTime - elapsed > EventTolerance)
                {
                    break;
                }

                ExecuteEvent(current);
                nextEvent++;
            }

            if (nextEvent >= schedule.Count)
            {
                CompleteInternal();
            }
        }

        public void Cancel()
        {
            if (cancelled || completed)
            {
                return;
            }

            cancelled = true;
            CompleteInternal();
        }

        public void Dispose()
        {
            if (!completed && !cancelled)
            {
                Cancel();
            }
        }

        private void CompleteInternal()
        {
            if (completed)
            {
                return;
            }

            completed = true;
            lockManager?.PopLock(baseLockReason);
            PublishLockEvent(false, baseLockReason);
        }

        private void ExecuteEvent(ScheduledEvent scheduled)
        {
            switch (scheduled.Type)
            {
                case ScheduledEventType.LockAcquire:
                    lockManager?.PushLock(scheduled.Reason);
                    PublishLockEvent(true, scheduled.Reason);
                    break;

                case ScheduledEventType.LockRelease:
                    lockManager?.PopLock(scheduled.Reason);
                    PublishLockEvent(false, scheduled.Reason);
                    break;

                case ScheduledEventType.WindowOpen:
                    PublishWindowEvent(scheduled, true);
                    break;

                case ScheduledEventType.WindowClose:
                    PublishWindowEvent(scheduled, false);
                    break;

                case ScheduledEventType.Impact:
                    PublishImpactEvent(scheduled);
                    break;

                case ScheduledEventType.PhaseEnter:
                    PublishPhaseEvent(scheduled);
                    break;
            }
        }

        private void PublishPhaseEvent(ScheduledEvent scheduled)
        {
            var evt = new AnimationPhaseEvent(
                request.Actor,
                request.Selection,
                scheduled.Index + 1,
                scheduled.TotalCount,
                scheduled.Payload);
            eventBus?.Publish(evt);
        }

        private void PublishImpactEvent(ScheduledEvent scheduled)
        {
            CombatantState target = null;
            if (request.Targets != null && request.Targets.Count > 0)
            {
                int clamped = Math.Min(scheduled.Index, request.Targets.Count - 1);
                target = request.Targets[clamped];
            }

            var evt = new AnimationImpactEvent(
                request.Actor,
                target,
                request.Selection.Action,
                scheduled.Index + 1,
                scheduled.TotalCount,
                scheduled.Tag,
                scheduled.Payload);

            eventBus?.Publish(evt);
        }

        private void PublishWindowEvent(ScheduledEvent scheduled, bool isOpening)
        {
            var evt = new AnimationWindowEvent(
                request.Actor,
                scheduled.Tag,
                scheduled.Phase.StartNormalized,
                scheduled.Phase.EndNormalized,
                isOpening);
            eventBus?.Publish(evt);
        }

        private void PublishLockEvent(bool locked, string reason)
        {
            var evt = new AnimationLockEvent(request.Actor, locked, reason);
            eventBus?.Publish(evt);
        }

        private static List<ScheduledEvent> BuildSchedule(CompiledTimeline timeline)
        {
            var events = new List<ScheduledEvent>();
            if (timeline.Phases == null)
            {
                return events;
            }

            int totalAnimation = CountPhases(timeline, ActionTimeline.TrackType.Animation);
            int totalImpacts = CountPhases(timeline, ActionTimeline.TrackType.Impact);
            int totalWindows = CountPhases(timeline, ActionTimeline.TrackType.Window);

            int animationIndex = 0;
            int impactIndex = 0;
            int windowIndex = 0;

            foreach (var phase in timeline.Phases)
            {
                string tag = ResolveTag(phase);
                switch (phase.Track)
                {
                    case ActionTimeline.TrackType.Animation:
                        events.Add(ScheduledEvent.ForPhase(phase.Start, phase, animationIndex, totalAnimation, tag, phase.Payload));
                        animationIndex++;
                        break;

                    case ActionTimeline.TrackType.Window:
                        events.Add(ScheduledEvent.ForWindow(phase.Start, ScheduledEventType.WindowOpen, phase, windowIndex, totalWindows, tag, phase.Payload));
                        events.Add(ScheduledEvent.ForWindow(phase.End, ScheduledEventType.WindowClose, phase, windowIndex, totalWindows, tag, phase.Payload));
                        windowIndex++;
                        break;

                    case ActionTimeline.TrackType.Impact:
                        events.Add(ScheduledEvent.ForImpact(phase.Start, phase, impactIndex, totalImpacts, tag, phase.Payload));
                        impactIndex++;
                        break;

                    case ActionTimeline.TrackType.Lock:
                        string reason = !string.IsNullOrWhiteSpace(phase.Payload)
                            ? phase.Payload
                            : (string.IsNullOrWhiteSpace(tag) ? timeline.ActionId : tag);
                        events.Add(ScheduledEvent.ForLock(phase.Start, ScheduledEventType.LockAcquire, phase, reason));
                        events.Add(ScheduledEvent.ForLock(phase.End, ScheduledEventType.LockRelease, phase, reason));
                        break;

                    case ActionTimeline.TrackType.Custom:
                        // Treat custom tracks as phases for now to keep telemetry.
                        events.Add(ScheduledEvent.ForPhase(phase.Start, phase, animationIndex, totalAnimation, tag, phase.Payload));
                        break;
                }
            }

            events.Sort(ScheduledEventComparer.Instance);
            return events;
        }

        private static int CountPhases(CompiledTimeline timeline, ActionTimeline.TrackType track)
        {
            int count = 0;
            if (timeline.Phases == null)
            {
                return count;
            }

            for (int i = 0; i < timeline.Phases.Count; i++)
            {
                if (timeline.Phases[i].Track == track)
                {
                    count++;
                }
            }
            return count;
        }

        private static string ResolveTag(CompiledPhase phase)
        {
            if (!string.IsNullOrWhiteSpace(phase.EnterEvent))
            {
                return phase.EnterEvent;
            }

            if (!string.IsNullOrWhiteSpace(phase.ExitEvent))
            {
                return phase.ExitEvent;
            }

            return phase.Payload;
        }

        private readonly struct ScheduledEvent
        {
            public ScheduledEvent(
                double triggerTime,
                ScheduledEventType type,
                CompiledPhase phase,
                int index,
                int totalCount,
                string tag,
                string payload,
                string reason)
            {
                TriggerTime = triggerTime;
                Type = type;
                Phase = phase;
                Index = index;
                TotalCount = totalCount;
                Tag = tag;
                Payload = payload;
                Reason = reason;
            }

            public double TriggerTime { get; }
            public ScheduledEventType Type { get; }
            public CompiledPhase Phase { get; }
            public int Index { get; }
            public int TotalCount { get; }
            public string Tag { get; }
            public string Payload { get; }
            public string Reason { get; }

            public static ScheduledEvent ForPhase(double time, CompiledPhase phase, int index, int total, string tag, string payload) =>
                new ScheduledEvent(time, ScheduledEventType.PhaseEnter, phase, index, Math.Max(1, total), tag, payload, null);

            public static ScheduledEvent ForWindow(double time, ScheduledEventType type, CompiledPhase phase, int index, int total, string tag, string payload) =>
                new ScheduledEvent(time, type, phase, index, Math.Max(1, total), tag, payload, null);

            public static ScheduledEvent ForImpact(double time, CompiledPhase phase, int index, int total, string tag, string payload) =>
                new ScheduledEvent(time, ScheduledEventType.Impact, phase, index, Math.Max(1, total), tag, payload, null);

            public static ScheduledEvent ForLock(double time, ScheduledEventType type, CompiledPhase phase, string reason) =>
                new ScheduledEvent(time, type, phase, 0, 0, null, null, reason);
        }

        private sealed class ScheduledEventComparer : IComparer<ScheduledEvent>
        {
            public static readonly ScheduledEventComparer Instance = new();

            public int Compare(ScheduledEvent x, ScheduledEvent y)
            {
                int timeComparison = x.TriggerTime.CompareTo(y.TriggerTime);
                if (timeComparison != 0)
                {
                    return timeComparison;
                }

                return GetPriority(x.Type).CompareTo(GetPriority(y.Type));
            }

            private static int GetPriority(ScheduledEventType type) =>
                type switch
                {
                    ScheduledEventType.LockAcquire => -10,
                    ScheduledEventType.WindowOpen => 0,
                    ScheduledEventType.Impact => 1,
                    ScheduledEventType.WindowClose => 2,
                    ScheduledEventType.PhaseEnter => 3,
                    ScheduledEventType.LockRelease => 4,
                    _ => 5
                };
        }
    }

    public enum ScheduledEventType
    {
        WindowOpen,
        WindowClose,
        Impact,
        LockAcquire,
        LockRelease,
        PhaseEnter
    }
}
==== END Assets/Scripts/BattleV2/AnimationSystem/Execution/ActionSequencer.cs ====

==== BEGIN Assets/Scripts/BattleV2/AnimationSystem/Execution/ActionSequencerDriver.cs ====
using System.Collections.Generic;
using UnityEngine;

namespace BattleV2.AnimationSystem.Execution
{
    /// <summary>
    /// MonoBehaviour utility that ticks registered <see cref="ActionSequencer"/> instances
    /// once per frame. Intended for prototypes and logging milestones.
    /// </summary>
    public sealed class ActionSequencerDriver : MonoBehaviour
    {
        [SerializeField] private CombatClock clock;

        private readonly List<ActionSequencer> activeSequencers = new();
        private readonly List<ActionSequencer> buffer = new();

        private void Awake()
        {
            clock ??= new CombatClock();
        }

        private void Update()
        {
            if (activeSequencers.Count == 0)
            {
                return;
            }

            clock.Sample();

            buffer.Clear();
            for (int i = 0; i < activeSequencers.Count; i++)
            {
                var seq = activeSequencers[i];
                seq.Tick();
                if (!seq.IsCompleted && !seq.IsCancelled)
                {
                    buffer.Add(seq);
                }
                else
                {
                    seq.Dispose();
                }
            }

            activeSequencers.Clear();
            activeSequencers.AddRange(buffer);
        }

        public void Register(ActionSequencer sequencer)
        {
            if (sequencer == null)
            {
                return;
            }

            sequencer.Start();
            activeSequencers.Add(sequencer);
        }
    }
}
==== END Assets/Scripts/BattleV2/AnimationSystem/Execution/ActionSequencerDriver.cs ====

==== BEGIN Assets/Scripts/BattleV2/AnimationSystem/Execution/TimelineRuntimeBuilder.cs ====
using System;
using BattleV2.AnimationSystem.Timelines;
using UnityEngine;

namespace BattleV2.AnimationSystem.Execution
{
    public sealed class TimelineRuntimeBuilder
    {
        private readonly ITimelineCompiler compiler;
        private readonly ICombatClock clock;
        private readonly IAnimationEventBus eventBus;
        private readonly IActionLockManager lockManager;

        public TimelineRuntimeBuilder(
            ITimelineCompiler compiler,
            ICombatClock clock,
            IAnimationEventBus eventBus,
            IActionLockManager lockManager)
        {
            this.compiler = compiler ?? throw new ArgumentNullException(nameof(compiler));
            this.clock = clock ?? throw new ArgumentNullException(nameof(clock));
            this.eventBus = eventBus ?? throw new ArgumentNullException(nameof(eventBus));
            this.lockManager = lockManager ?? throw new ArgumentNullException(nameof(lockManager));
        }

        public ActionSequencer Create(AnimationRequest request, ActionTimeline timeline)
        {
            if (timeline == null)
            {
                throw new ArgumentNullException(nameof(timeline));
            }

            float timelineDuration = ResolveDuration(timeline);
            var compiled = compiler.Compile(timeline, timelineDuration);
            return new ActionSequencer(request, compiled, clock, eventBus, lockManager);
        }

        private static float ResolveDuration(ActionTimeline timeline)
        {
            float duration = timeline.Info.Length;
            if (duration <= 0f)
            {
                duration = 1f;
            }

            return Mathf.Max(0.1f, duration);
        }
    }
}
==== END Assets/Scripts/BattleV2/AnimationSystem/Execution/TimelineRuntimeBuilder.cs ====

==== BEGIN Assets/Editor/AnimationSystem/AnimationSystemGuardrails.cs ====
#if UNITY_EDITOR
using System.IO;
using UnityEditor;
using UnityEngine;

namespace BattleV2.AnimationSystem.Editor
{
    [InitializeOnLoad]
    public static class AnimationSystemGuardrails
    {
        private const string ManagerPath = "Assets/Scripts/BattleV2/Orchestration/BattleManagerV2.cs";
        private const string RequiredInvocation = "PlayAsync(";

        static AnimationSystemGuardrails()
        {
            ValidateBattleManagerContract();
        }

        private static void ValidateBattleManagerContract()
        {
            if (!File.Exists(ManagerPath))
            {
                return;
            }

            string contents = File.ReadAllText(ManagerPath);
            if (!contents.Contains(RequiredInvocation))
            {
                Debug.LogError("[AnimationSystemGuardrails] BattleManagerV2 must continue invoking PlayAsync on the orchestrator. Please restore the contract before committing.");
            }
        }
    }
}
#endif
==== END Assets/Editor/AnimationSystem/AnimationSystemGuardrails.cs ====

==== BEGIN Assets/Editor/AnimationSystem/ActionTimelineCatalogValidatorEditor.cs ====
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;
using BattleV2.AnimationSystem.Catalog;
using BattleV2.AnimationSystem.Validation;

namespace BattleV2.AnimationSystem.Editor
{
    public static class ActionTimelineCatalogValidatorEditor
    {
        [MenuItem("Battle/Animation/Validate Action Timeline Catalog")]
        public static void ValidateCatalog()
        {
            var catalogs = CollectCatalogsFromSelection();
            if (catalogs.Count == 0)
            {
                Debug.LogWarning("[ActionTimelineCatalogValidator] Selecciona al menos un ActionTimelineCatalog para validar.");
                return;
            }

            int totalTimelines = 0;
            int totalErrors = 0;
            int totalWarnings = 0;

            foreach (var catalog in catalogs)
            {
                catalog.ForceRebuild();
                var timelines = catalog.Timelines;
                if (timelines == null || timelines.Count == 0)
                {
                    Debug.LogWarning($"[ActionTimelineCatalogValidator] '{catalog.name}' está vacío.");
                    continue;
                }

                int catalogErrors = 0;
                int catalogWarnings = 0;

                foreach (var timeline in timelines)
                {
                    var result = ActionTimelineValidator.Validate(timeline);
                    catalogErrors += result.ErrorCount;
                    catalogWarnings += result.WarningCount;

                    if (result.Errors != null)
                    {
                        foreach (var error in result.Errors)
                        {
                            Debug.LogError($"[ActionTimelineCatalogValidator] {catalog.name}/{timeline.ActionId}: {error}");
                        }
                    }

                    if (result.Warnings != null)
                    {
                        foreach (var warning in result.Warnings)
                        {
                            Debug.LogWarning($"[ActionTimelineCatalogValidator] {catalog.name}/{timeline.ActionId}: {warning}");
                        }
                    }
                }

                totalTimelines += timelines.Count;
                totalErrors += catalogErrors;
                totalWarnings += catalogWarnings;

                if (catalogErrors == 0 && catalogWarnings == 0)
                {
                    Debug.Log($"[ActionTimelineCatalogValidator] '{catalog.name}' validación exitosa ({timelines.Count} timelines, sin hallazgos).");
                }
                else
                {
                    Debug.Log($"[ActionTimelineCatalogValidator] '{catalog.name}' resumen -> {timelines.Count} timelines | {catalogErrors} errores | {catalogWarnings} warnings.");
                }
            }

            Debug.Log($"[ActionTimelineCatalogValidator] Resultado global -> Catálogos: {catalogs.Count}, Timelines Analizados: {totalTimelines}, Errores: {totalErrors}, Warnings: {totalWarnings}.");
        }

        private static HashSet<ActionTimelineCatalog> CollectCatalogsFromSelection()
        {
            var catalogs = new HashSet<ActionTimelineCatalog>();
            foreach (var obj in Selection.objects)
            {
                if (obj is ActionTimelineCatalog catalog)
                {
                    catalogs.Add(catalog);
                }
            }

            if (catalogs.Count == 0 && Selection.activeObject is ActionTimelineCatalog active)
            {
                catalogs.Add(active);
            }

            return catalogs;
        }
    }
}
==== END Assets/Editor/AnimationSystem/ActionTimelineCatalogValidatorEditor.cs ====

